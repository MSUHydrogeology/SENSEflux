function [varargout] = trim_domain(maskOrIndices,varargin)
%TRIM_DOMAIN  Using an input mask, return a subset of elements.
%   varargout = trim_domain(maskOrIndices,varargin)
%
%   This function outputs new arrays containing only active areas of the model
%   domain. It also outputs an array 'modelIndices' which can be used to
%   recreate the original arrays using the function "extend_domain".
%
%   Descriptions of Input Variables:
%   maskOrIndices: either the boundary mask (an MxN array
%       of model dimensions) or the modelIndices array (an Lx1 list of the
%       indices of the boundary mask found within the model).  The modelIndices
%       array would have been generated by a previous run of this function.
%   varargin: Can be any number of input arrays consituting a mix of
%       cell, structured, numeric, or logical types.  In addition, arrays
%       of dimension MxNxO are acceptable as well.  In these cases, the model
%       indices array is applied to each "sheet" in the Oth dimension.  It is NOT
%       a 3-D interpolation.  Another note, structured arrays can contain
%       structure,cell, and numeric/logical arrays, and cell arrays can contain
%       other cell ararys, or numeric/logical arrays.  There is no limitation on 
%       recursive depth.If other data types are contained within an input 
%       datatype, a warning will be displayed and the input will not be
%       modified.
%
%   Descriptions of Output Variables:
%   The output will be of the same order and class(es) as the input.
%
%   Example(s):
%   >> [partET,partRecharge] = trim_domain(boundaryMask, fullET,
%   fullRecharge);
%   >> [trimStruct] = trim_domain(modelIndices); %transform a model index
%   grid (all 0 and 1 values) into the necessary input for this function
%
%   See also: extend_domain

% Author: Anthony Kendall
% Contact: anthony [dot] kendall [at] gmail [dot] com
% Created: 2008-03-11
% Copyright 2008 Michigan State University.

%generate modelIndices, if necessary
if ~isstruct(maskOrIndices)
    structIndices.indices = (maskOrIndices==1);
    structIndices.origSize = size(maskOrIndices);
    structIndices.trimSize = sum(maskOrIndices(:));
else
    structIndices = maskOrIndices;
end
modelIndices = structIndices.indices;
origSize = structIndices.origSize;
trimSize = structIndices.trimSize;

%go through the inputs and trim them using modelIndices
for m = 1:length(varargin)
    input = varargin{m};
    if isnumeric(input) || islogical(input)
        output = numeric_trim(input,modelIndices,origSize,trimSize);
    elseif isstruct(input)
        output = struct_trim(input,modelIndices,origSize,trimSize);
    elseif iscell(input)
        output = cell_trim(input,modelIndices,origSize,trimSize);        
    else
%         warning('This function only supports arrays of type cell, struct, numeric, or logical')
        output = input;
    end
    varargout{m} = output;
end
if isempty(m)
    m = 0;
end
if nargout == (length(varargin)+1)
    varargout{m+1} = structIndices;
end
end

function [output] = struct_trim(input,modelIndices,origSize,trimSize)
fields = fieldnames(input);
output = input;
for m = 1:length(fields)
    if isstruct(input.(fields{m}))
        output.(fields{m}) = struct_trim(input.(fields{m}),modelIndices,origSize,trimSize);
    elseif iscell(input.(fields{m}))
        output.(fields{m}) = cell_trim(input.(fields{m}),modelIndices,origSize,trimSize);
    elseif isnumeric(input.(fields{m})) || islogical(input.(fields{m}))
        output.(fields{m}) = numeric_trim(input.(fields{m}),modelIndices,origSize,trimSize);
    else %must be an unsupported data type
%        warning('This function only supports arrays of type cell, struct, numeric, or logical')
       output.(fields{m}) = input.(fields{m});
    end
end
end

function [output] = cell_trim(input,modelIndices,origSize,trimSize)
output = input;
for m = 1:numel(input)
    if iscell(input{m})
        output{m} = cell_trim(input{m},modelIndices,origSize,trimSize);
    elseif isnumeric(input{m}) || islogical(input{m})
        output{m} = numeric_trim(input{m},modelIndices,origSize,trimSize);
    else %must be an unsupported data type
%         warning('This function only supports arrays of type cell, struct, numeric, or logical')
        output{m} = input{m};
    end
end
end

function [output] = numeric_trim(input,modelIndices,origSize,trimSize)
test = numel(input)./(origSize(1)*origSize(2));
if rem(test,1) == 0 && ~isempty(input)
    numLay = floor(test);
    if isnumeric(input)
        output = zeros([trimSize,numLay],class(input));
    else %this is a logical array
        output = false([trimSize,numLay]);
    end
    for n = 1:numLay
        if size(input,3)>1
            tempOutput = input(:,:,n);
            output(:,n) = tempOutput(modelIndices);
        elseif size(input,2)~=numLay
            tempOutput = input(:,:);
            output(:,n) = tempOutput(modelIndices);
        else
            output(:,n) = input(modelIndices,n);
        end
    end
else
%     warning('Numeric or logical arrays not of size MxN were left unmodified')
    output = input;
end
end

  